ok: class CLASS ::.Video : , name: Video, base: 


===== Header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/tracking_c.h =====
Namespaces: set([''])
Ignore header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/tracking_c.h


===== Header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video.hpp =====
Namespaces: set([''])
Ignore header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video.hpp


===== Header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/background_segm.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[u'class cv.BackgroundSubtractor', ': cv::Algorithm', [], []]
ok: class CLASS cv::.BackgroundSubtractor : Algorithm, name: BackgroundSubtractor, base: Algorithm

--- Incoming ---
[   u'cv.BackgroundSubtractor.apply',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.BackgroundSubtractor.getBackgroundImage',
    u'void',
    [],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[u'class cv.BackgroundSubtractorMOG2', u': cv::BackgroundSubtractor', [], []]
ok: class CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor, name: BackgroundSubtractorMOG2, base: BackgroundSubtractor

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getHistory', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setHistory',
    u'void',
    [],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getNMixtures', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setNMixtures',
    u'void',
    [],
    [[u'int', u'nmixtures', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getBackgroundRatio',
    u'double',
    [],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setBackgroundRatio',
    u'void',
    [],
    [[u'double', u'ratio', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getVarThreshold', u'double', [], [], u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThreshold',
    u'void',
    [],
    [[u'double', u'varThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThresholdGen',
    u'double',
    [],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThresholdGen',
    u'void',
    [],
    [[u'double', u'varThresholdGen', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getVarInit', u'double', [], [], u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarInit',
    u'void',
    [],
    [[u'double', u'varInit', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getVarMin', u'double', [], [], u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMin',
    u'void',
    [],
    [[u'double', u'varMin', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getVarMax', u'double', [], [], u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMax',
    u'void',
    [],
    [[u'double', u'varMax', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold',
    u'double',
    [],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold',
    u'void',
    [],
    [[u'double', u'ct', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getDetectShadows', u'bool', [], [], u'bool']
ok: FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setDetectShadows',
    u'void',
    [],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[u'cv.BackgroundSubtractorMOG2.getShadowValue', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowValue',
    u'void',
    [],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowThreshold',
    u'double',
    [],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowThreshold',
    u'void',
    [],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorMOG2',
    u'Ptr_BackgroundSubtractorMOG2',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'varThreshold', u'16', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorMOG2>']
ok: FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>

--- Incoming ---
[u'class cv.BackgroundSubtractorKNN', u': cv::BackgroundSubtractor', [], []]
ok: class CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor, name: BackgroundSubtractorKNN, base: BackgroundSubtractor

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getHistory', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setHistory',
    u'void',
    [],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getNSamples', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setNSamples',
    u'void',
    [],
    [[u'int', u'_nN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getDist2Threshold', u'double', [], [], u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDist2Threshold',
    u'void',
    [],
    [[u'double', u'_dist2Threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getkNNSamples', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setkNNSamples',
    u'void',
    [],
    [[u'int', u'_nkNN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getDetectShadows', u'bool', [], [], u'bool']
ok: FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDetectShadows',
    u'void',
    [],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[u'cv.BackgroundSubtractorKNN.getShadowValue', u'int', [], [], u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowValue',
    u'void',
    [],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowThreshold',
    u'double',
    [],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowThreshold',
    u'void',
    [],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorKNN',
    u'Ptr_BackgroundSubtractorKNN',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'dist2Threshold', u'400.0', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorKNN>']
ok: FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>


===== Header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/tracking.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[u'const cv.OPTFLOW_USE_INITIAL_FLOW', u'4', [], []]
ok: CONST OPTFLOW_USE_INITIAL_FLOW=4

--- Incoming ---
[u'const cv.OPTFLOW_LK_GET_MIN_EIGENVALS', u'8', [], []]
ok: CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8

--- Incoming ---
[u'const cv.OPTFLOW_FARNEBACK_GAUSSIAN', u'256', [], []]
ok: CONST OPTFLOW_FARNEBACK_GAUSSIAN=256

--- Incoming ---
[   u'cv.CamShift',
    u'RotatedRect',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.meanShift',
    u'int',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'int']
ok: FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.buildOpticalFlowPyramid',
    u'int',
    [],
    [   ['Mat', u'img', '', []],
        ['vector_Mat', u'pyramid', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'maxLevel', u'', []],
        [u'bool', u'withDerivatives', u'true', []],
        [u'int', u'pyrBorder', u'BORDER_REFLECT_101', []],
        [u'int', u'derivBorder', u'BORDER_CONSTANT', []],
        [u'bool', u'tryReuseInputImage', u'true', []]],
    u'int']
ok: FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>

--- Incoming ---
[   u'cv.calcOpticalFlowPyrLK',
    u'void',
    [],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', '', ['/O']],
        [u'Size', u'winSize', u'Size(21,21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
[   u'cv.calcOpticalFlowFarneback',
    u'void',
    [],
    [   ['Mat', u'prev', '', []],
        ['Mat', u'next', '', []],
        ['Mat', u'flow', '', ['/IO']],
        [u'double', u'pyr_scale', u'', []],
        [u'int', u'levels', u'', []],
        [u'int', u'winsize', u'', []],
        [u'int', u'iterations', u'', []],
        [u'int', u'poly_n', u'', []],
        [u'double', u'poly_sigma', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>

--- Incoming ---
[   u'cv.estimateRigidTransform',
    u'Mat',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        [u'bool', u'fullAffine', u'', []]],
    u'Mat']
ok: FUNC <Mat cv..estimateRigidTransform [ARG Mat src=, ARG Mat dst=, ARG bool fullAffine=]>

--- Incoming ---
[u'const cv.MOTION_TRANSLATION', u'0', [], []]
ok: CONST MOTION_TRANSLATION=0

--- Incoming ---
[u'const cv.MOTION_EUCLIDEAN', u'1', [], []]
ok: CONST MOTION_EUCLIDEAN=1

--- Incoming ---
[u'const cv.MOTION_AFFINE', u'2', [], []]
ok: CONST MOTION_AFFINE=2

--- Incoming ---
[u'const cv.MOTION_HOMOGRAPHY', u'3', [], []]
ok: CONST MOTION_HOMOGRAPHY=3

--- Incoming ---
[   u'cv.findTransformECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'warpMatrix', '', ['/IO']],
        [u'int', u'motionType', u'MOTION_AFFINE', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001)',
            []],
        ['Mat', u'inputMask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>

--- Incoming ---
[   u'class cv.KalmanFilter',
    '',
    [],
    [   [u'Mat', u'statePre', '', ['/RW']],
        [u'Mat', u'statePost', '', ['/RW']],
        [u'Mat', u'transitionMatrix', '', ['/RW']],
        [u'Mat', u'controlMatrix', '', ['/RW']],
        [u'Mat', u'measurementMatrix', '', ['/RW']],
        [u'Mat', u'processNoiseCov', '', ['/RW']],
        [u'Mat', u'measurementNoiseCov', '', ['/RW']],
        [u'Mat', u'errorCovPre', '', ['/RW']],
        [u'Mat', u'gain', '', ['/RW']],
        [u'Mat', u'errorCovPost', '', ['/RW']]]]
ok: class CLASS cv::.KalmanFilter : , name: KalmanFilter, base: 

--- Incoming ---
[u'cv.KalmanFilter.KalmanFilter', '', [], []]
ok: FUNC < cv.KalmanFilter.KalmanFilter []>

--- Incoming ---
[   u'cv.KalmanFilter.KalmanFilter',
    '',
    [],
    [   [u'int', u'dynamParams', u'', []],
        [u'int', u'measureParams', u'', []],
        [u'int', u'controlParams', u'0', []],
        [u'int', u'type', u'CV_32F', []]]]
ok: FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>

--- Incoming ---
[   u'cv.KalmanFilter.predict',
    u'Mat',
    [],
    [[u'Mat', u'control', u'Mat()', []]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>

--- Incoming ---
[   u'cv.KalmanFilter.correct',
    u'Mat',
    [],
    [[u'Mat', u'measurement', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>

--- Incoming ---
[u'class cv.DenseOpticalFlow', ': cv::Algorithm', [], []]
ok: class CLASS cv::.DenseOpticalFlow : Algorithm, name: DenseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.DenseOpticalFlow.calc',
    u'void',
    [],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>

--- Incoming ---
[u'cv.DenseOpticalFlow.collectGarbage', u'void', [], [], u'void']
ok: FUNC <void cv.DenseOpticalFlow.collectGarbage []>

--- Incoming ---
[u'class cv.SparseOpticalFlow', ': cv::Algorithm', [], []]
ok: class CLASS cv::.SparseOpticalFlow : Algorithm, name: SparseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.SparseOpticalFlow.calc',
    u'void',
    [],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', u'cv::Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>

--- Incoming ---
[u'class cv.DualTVL1OpticalFlow', u': cv::DenseOpticalFlow', [], []]
ok: class CLASS cv::.DualTVL1OpticalFlow : DenseOpticalFlow, name: DualTVL1OpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getTau', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getTau []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setTau',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setTau [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getLambda', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getLambda []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setLambda',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setLambda [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getTheta', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getTheta []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setTheta',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setTheta [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getGamma', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getGamma []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setGamma',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setGamma [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getScalesNumber', u'int', [], [], u'int']
ok: FUNC <int cv.DualTVL1OpticalFlow.getScalesNumber []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setScalesNumber',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setScalesNumber [ARG int val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getWarpingsNumber', u'int', [], [], u'int']
ok: FUNC <int cv.DualTVL1OpticalFlow.getWarpingsNumber []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setWarpingsNumber',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setWarpingsNumber [ARG int val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getEpsilon', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getEpsilon []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setEpsilon',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setEpsilon [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getInnerIterations', u'int', [], [], u'int']
ok: FUNC <int cv.DualTVL1OpticalFlow.getInnerIterations []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setInnerIterations',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setInnerIterations [ARG int val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getOuterIterations', u'int', [], [], u'int']
ok: FUNC <int cv.DualTVL1OpticalFlow.getOuterIterations []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setOuterIterations',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setOuterIterations [ARG int val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getUseInitialFlow', u'bool', [], [], u'bool']
ok: FUNC <bool cv.DualTVL1OpticalFlow.getUseInitialFlow []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setUseInitialFlow',
    u'void',
    [],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setUseInitialFlow [ARG bool val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getScaleStep', u'double', [], [], u'double']
ok: FUNC <double cv.DualTVL1OpticalFlow.getScaleStep []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setScaleStep',
    u'void',
    [],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setScaleStep [ARG double val=]>

--- Incoming ---
[u'cv.DualTVL1OpticalFlow.getMedianFiltering', u'int', [], [], u'int']
ok: FUNC <int cv.DualTVL1OpticalFlow.getMedianFiltering []>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.setMedianFiltering',
    u'void',
    [],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DualTVL1OpticalFlow.setMedianFiltering [ARG int val=]>

--- Incoming ---
[   u'cv.DualTVL1OpticalFlow.create',
    u'Ptr_DualTVL1OpticalFlow',
    ['/S'],
    [   [u'double', u'tau', u'0.25', []],
        [u'double', u'lambda', u'0.15', []],
        [u'double', u'theta', u'0.3', []],
        [u'int', u'nscales', u'5', []],
        [u'int', u'warps', u'5', []],
        [u'double', u'epsilon', u'0.01', []],
        [u'int', u'innnerIterations', u'30', []],
        [u'int', u'outerIterations', u'10', []],
        [u'double', u'scaleStep', u'0.8', []],
        [u'double', u'gamma', u'0.0', []],
        [u'int', u'medianFiltering', u'5', []],
        [u'bool', u'useInitialFlow', u'false', []]],
    u'Ptr<DualTVL1OpticalFlow>']
ok: FUNC <Ptr_DualTVL1OpticalFlow cv.DualTVL1OpticalFlow.create [ARG double tau=0.25, ARG double lambda=0.15, ARG double theta=0.3, ARG int nscales=5, ARG int warps=5, ARG double epsilon=0.01, ARG int innnerIterations=30, ARG int outerIterations=10, ARG double scaleStep=0.8, ARG double gamma=0.0, ARG int medianFiltering=5, ARG bool useInitialFlow=false]>

--- Incoming ---
[   u'cv.createOptFlow_DualTVL1',
    u'Ptr_DualTVL1OpticalFlow',
    [],
    [],
    u'Ptr<DualTVL1OpticalFlow>']
ok: FUNC <Ptr_DualTVL1OpticalFlow cv..createOptFlow_DualTVL1 []>

--- Incoming ---
[u'class cv.FarnebackOpticalFlow', u': cv::DenseOpticalFlow', [], []]
ok: class CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow, name: FarnebackOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getNumLevels', u'int', [], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumLevels',
    u'void',
    [],
    [[u'int', u'numLevels', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getPyrScale', u'double', [], [], u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPyrScale',
    u'void',
    [],
    [[u'double', u'pyrScale', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getFastPyramids', u'bool', [], [], u'bool']
ok: FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFastPyramids',
    u'void',
    [],
    [[u'bool', u'fastPyramids', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getWinSize', u'int', [], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setWinSize',
    u'void',
    [],
    [[u'int', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getNumIters', u'int', [], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumIters []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumIters',
    u'void',
    [],
    [[u'int', u'numIters', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getPolyN', u'int', [], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getPolyN []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolyN',
    u'void',
    [],
    [[u'int', u'polyN', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getPolySigma', u'double', [], [], u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolySigma',
    u'void',
    [],
    [[u'double', u'polySigma', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getFlags', u'int', [], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFlags',
    u'void',
    [],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.create',
    u'Ptr_FarnebackOpticalFlow',
    ['/S'],
    [   [u'int', u'numLevels', u'5', []],
        [u'double', u'pyrScale', u'0.5', []],
        [u'bool', u'fastPyramids', u'false', []],
        [u'int', u'winSize', u'13', []],
        [u'int', u'numIters', u'10', []],
        [u'int', u'polyN', u'5', []],
        [u'double', u'polySigma', u'1.1', []],
        [u'int', u'flags', u'0', []]],
    u'Ptr<FarnebackOpticalFlow>']
ok: FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>

--- Incoming ---
[u'class cv.SparsePyrLKOpticalFlow', u': cv::SparseOpticalFlow', [], []]
ok: class CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow, name: SparsePyrLKOpticalFlow, base: SparseOpticalFlow

--- Incoming ---
[u'cv.SparsePyrLKOpticalFlow.getWinSize', u'Size', [], [], u'Size']
ok: FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setWinSize',
    u'void',
    [],
    [[u'Size', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>

--- Incoming ---
[u'cv.SparsePyrLKOpticalFlow.getMaxLevel', u'int', [], [], u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMaxLevel',
    u'void',
    [],
    [[u'int', u'maxLevel', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getTermCriteria',
    u'TermCriteria',
    [],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setTermCriteria',
    u'void',
    [],
    [[u'TermCriteria', u'crit', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>

--- Incoming ---
[u'cv.SparsePyrLKOpticalFlow.getFlags', u'int', [], [], u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setFlags',
    u'void',
    [],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[u'cv.SparsePyrLKOpticalFlow.getMinEigThreshold', u'double', [], [], u'double']
ok: FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMinEigThreshold',
    u'void',
    [],
    [[u'double', u'minEigThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.create',
    u'Ptr_SparsePyrLKOpticalFlow',
    ['/S'],
    [   [u'Size', u'winSize', u'Size(21, 21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'crit',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'Ptr<SparsePyrLKOpticalFlow>']
ok: FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>


===== Header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/video.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /home/xxa344/Desktop/opencv-3.2.0/modules/video/include/opencv2/video/video.hpp


===== Generating... =====
CLASS cv::.DualTVL1OpticalFlow : DenseOpticalFlow
FUNC <Ptr_DualTVL1OpticalFlow cv.DualTVL1OpticalFlow.create [ARG double tau=0.25, ARG double lambda=0.15, ARG double theta=0.3, ARG int nscales=5, ARG int warps=5, ARG double epsilon=0.01, ARG int innnerIterations=30, ARG int outerIterations=10, ARG double scaleStep=0.8, ARG double gamma=0.0, ARG int medianFiltering=5, ARG bool useInitialFlow=false]>
java: DualTVL1OpticalFlow create(double tau, double lambda, double theta, int nscales, int warps, double epsilon, int innnerIterations, int outerIterations, double scaleStep, double gamma, int medianFiltering, boolean useInitialFlow)
java: DualTVL1OpticalFlow create()
FUNC <bool cv.DualTVL1OpticalFlow.getUseInitialFlow []>
java: boolean getUseInitialFlow()
FUNC <double cv.DualTVL1OpticalFlow.getEpsilon []>
java: double getEpsilon()
FUNC <double cv.DualTVL1OpticalFlow.getGamma []>
java: double getGamma()
FUNC <double cv.DualTVL1OpticalFlow.getLambda []>
java: double getLambda()
FUNC <double cv.DualTVL1OpticalFlow.getScaleStep []>
java: double getScaleStep()
FUNC <double cv.DualTVL1OpticalFlow.getTau []>
java: double getTau()
FUNC <double cv.DualTVL1OpticalFlow.getTheta []>
java: double getTheta()
FUNC <int cv.DualTVL1OpticalFlow.getInnerIterations []>
java: int getInnerIterations()
FUNC <int cv.DualTVL1OpticalFlow.getMedianFiltering []>
java: int getMedianFiltering()
FUNC <int cv.DualTVL1OpticalFlow.getOuterIterations []>
java: int getOuterIterations()
FUNC <int cv.DualTVL1OpticalFlow.getScalesNumber []>
java: int getScalesNumber()
FUNC <int cv.DualTVL1OpticalFlow.getWarpingsNumber []>
java: int getWarpingsNumber()
FUNC <void cv.DualTVL1OpticalFlow.setEpsilon [ARG double val=]>
java: void setEpsilon(double val)
FUNC <void cv.DualTVL1OpticalFlow.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <void cv.DualTVL1OpticalFlow.setInnerIterations [ARG int val=]>
java: void setInnerIterations(int val)
FUNC <void cv.DualTVL1OpticalFlow.setLambda [ARG double val=]>
java: void setLambda(double val)
FUNC <void cv.DualTVL1OpticalFlow.setMedianFiltering [ARG int val=]>
java: void setMedianFiltering(int val)
FUNC <void cv.DualTVL1OpticalFlow.setOuterIterations [ARG int val=]>
java: void setOuterIterations(int val)
FUNC <void cv.DualTVL1OpticalFlow.setScaleStep [ARG double val=]>
java: void setScaleStep(double val)
FUNC <void cv.DualTVL1OpticalFlow.setScalesNumber [ARG int val=]>
java: void setScalesNumber(int val)
FUNC <void cv.DualTVL1OpticalFlow.setTau [ARG double val=]>
java: void setTau(double val)
FUNC <void cv.DualTVL1OpticalFlow.setTheta [ARG double val=]>
java: void setTheta(double val)
FUNC <void cv.DualTVL1OpticalFlow.setUseInitialFlow [ARG bool val=]>
java: void setUseInitialFlow(boolean val)
FUNC <void cv.DualTVL1OpticalFlow.setWarpingsNumber [ARG int val=]>
java: void setWarpingsNumber(int val)
CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow
FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags, double minEigThreshold)
java: SparsePyrLKOpticalFlow create()
FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>
java: Size getWinSize()
FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>
java: double getMinEigThreshold()
FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>
java: int getMaxLevel()
FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>
java: void setMaxLevel(int maxLevel)
FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>
java: void setMinEigThreshold(double minEigThreshold)
FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>
java: void setTermCriteria(TermCriteria crit)
FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>
java: void setWinSize(Size winSize)
CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow
FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma, int flags)
java: FarnebackOpticalFlow create()
FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>
java: boolean getFastPyramids()
FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>
java: double getPolySigma()
FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>
java: double getPyrScale()
FUNC <int cv.FarnebackOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.FarnebackOpticalFlow.getNumIters []>
java: int getNumIters()
FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>
java: int getNumLevels()
FUNC <int cv.FarnebackOpticalFlow.getPolyN []>
java: int getPolyN()
FUNC <int cv.FarnebackOpticalFlow.getWinSize []>
java: int getWinSize()
FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>
java: void setFastPyramids(boolean fastPyramids)
FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>
java: void setNumIters(int numIters)
FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>
java: void setNumLevels(int numLevels)
FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>
java: void setPolyN(int polyN)
FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>
java: void setPolySigma(double polySigma)
FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>
java: void setPyrScale(double pyrScale)
FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>
java: void setWinSize(int winSize)
CLASS cv::.SparseOpticalFlow : Algorithm
FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status, Mat err)
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status)
CLASS cv::.DenseOpticalFlow : Algorithm
FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>
java: void calc(Mat I0, Mat I1, Mat flow)
FUNC <void cv.DenseOpticalFlow.collectGarbage []>
java: void collectGarbage()
CLASS cv::.BackgroundSubtractor : Algorithm
FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS ::.Video : 
[CONST CV_LKFLOW_INITIAL_GUESSES=4(manual), CONST CV_LKFLOW_GET_MIN_EIGENVALS=8(manual)]
[CONST OPTFLOW_USE_INITIAL_FLOW=4, CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8, CONST OPTFLOW_FARNEBACK_GAUSSIAN=256, CONST MOTION_TRANSLATION=0, CONST MOTION_EUCLIDEAN=1, CONST MOTION_AFFINE=2, CONST MOTION_HOMOGRAPHY=3]
FUNC <Mat cv..estimateRigidTransform [ARG Mat src=, ARG Mat dst=, ARG bool fullAffine=]>
java: Mat estimateRigidTransform(Mat src, Mat dst, boolean fullAffine)
FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold, boolean detectShadows)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN()
FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold, boolean detectShadows)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2()
FUNC <Ptr_DualTVL1OpticalFlow cv..createOptFlow_DualTVL1 []>
java: DualTVL1OpticalFlow createOptFlow_DualTVL1()
FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: RotatedRect CamShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix)
FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder, boolean tryReuseInputImage)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel)
FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: int meanShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>
java: void calcOpticalFlowFarneback(Mat prev, Mat next, Mat flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)
FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err)
CLASS cv::.KalmanFilter : 
FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)
java:  KalmanFilter(int dynamParams, int measureParams)
FUNC < cv.KalmanFilter.KalmanFilter []>
java:  KalmanFilter()
FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>
java: Mat correct(Mat measurement)
FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>
java: Mat predict(Mat control)
java: Mat predict()
FUNC <Mat cv.KalmanFilter.get_statePre []>
java: Mat get_statePre()
FUNC <void cv.KalmanFilter.set_statePre [ARG Mat statePre=]>
java: void set_statePre(Mat statePre)
FUNC <Mat cv.KalmanFilter.get_statePost []>
java: Mat get_statePost()
FUNC <void cv.KalmanFilter.set_statePost [ARG Mat statePost=]>
java: void set_statePost(Mat statePost)
FUNC <Mat cv.KalmanFilter.get_transitionMatrix []>
java: Mat get_transitionMatrix()
FUNC <void cv.KalmanFilter.set_transitionMatrix [ARG Mat transitionMatrix=]>
java: void set_transitionMatrix(Mat transitionMatrix)
FUNC <Mat cv.KalmanFilter.get_controlMatrix []>
java: Mat get_controlMatrix()
FUNC <void cv.KalmanFilter.set_controlMatrix [ARG Mat controlMatrix=]>
java: void set_controlMatrix(Mat controlMatrix)
FUNC <Mat cv.KalmanFilter.get_measurementMatrix []>
java: Mat get_measurementMatrix()
FUNC <void cv.KalmanFilter.set_measurementMatrix [ARG Mat measurementMatrix=]>
java: void set_measurementMatrix(Mat measurementMatrix)
FUNC <Mat cv.KalmanFilter.get_processNoiseCov []>
java: Mat get_processNoiseCov()
FUNC <void cv.KalmanFilter.set_processNoiseCov [ARG Mat processNoiseCov=]>
java: void set_processNoiseCov(Mat processNoiseCov)
FUNC <Mat cv.KalmanFilter.get_measurementNoiseCov []>
java: Mat get_measurementNoiseCov()
FUNC <void cv.KalmanFilter.set_measurementNoiseCov [ARG Mat measurementNoiseCov=]>
java: void set_measurementNoiseCov(Mat measurementNoiseCov)
FUNC <Mat cv.KalmanFilter.get_errorCovPre []>
java: Mat get_errorCovPre()
FUNC <void cv.KalmanFilter.set_errorCovPre [ARG Mat errorCovPre=]>
java: void set_errorCovPre(Mat errorCovPre)
FUNC <Mat cv.KalmanFilter.get_gain []>
java: Mat get_gain()
FUNC <void cv.KalmanFilter.set_gain [ARG Mat gain=]>
java: void set_gain(Mat gain)
FUNC <Mat cv.KalmanFilter.get_errorCovPost []>
java: Mat get_errorCovPost()
FUNC <void cv.KalmanFilter.set_errorCovPost [ARG Mat errorCovPost=]>
java: void set_errorCovPost(Mat errorCovPost)
CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>
java: double getComplexityReductionThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>
java: double getVarInit()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>
java: double getVarMax()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>
java: double getVarMin()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>
java: double getVarThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>
java: double getVarThresholdGen()
FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>
java: int getNMixtures()
FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>
java: void setBackgroundRatio(double ratio)
FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>
java: void setComplexityReductionThreshold(double ct)
FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>
java: void setNMixtures(int nmixtures)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>
java: void setVarInit(double varInit)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>
java: void setVarMax(double varMax)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>
java: void setVarMin(double varMin)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>
java: void setVarThreshold(double varThreshold)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>
java: void setVarThresholdGen(double varThresholdGen)
CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>
java: double getDist2Threshold()
FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <int cv.BackgroundSubtractorKNN.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>
java: int getNSamples()
FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>
java: int getShadowValue()
FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>
java: int getkNNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>
java: void setDist2Threshold(double _dist2Threshold)
FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>
java: void setNSamples(int _nN)
FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>
java: void setkNNSamples(int _nkNN)
